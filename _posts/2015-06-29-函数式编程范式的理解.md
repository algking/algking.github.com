---
layout: post
category: "lisp"
description: "å‡½æ•°å¼è¯­è¨€ç¼–ç¨‹ç³»åˆ—-Functional Design Pattern"
tags: [haskell,lisp,erlang]
---
### å‡½æ•°å¼è¯­è¨€è®¾è®¡æ¨¡å¼### 
æœ€è¿‘çœ‹äº†ä¸€ä¸ªè§†é¢‘ï¼Œæ˜¯[ScottWlaschin](URL )åœ¨ä¼¦æ•¦è¿›è¡Œä¸€ä¸ªå…³äºå‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼çš„æ¼”è®²
è¿™ä¸ªæ¼”è®²ç»™äº†æˆ‘å¾ˆå¤šå¯å‘ï¼Œæ‰€ä»¥é¡ºä¾¿ç»“åˆè‡ªå·±çš„ç†è§£ï¼Œåšä¸€ä¸‹ç»ˆç»“ã€‚

### Functional Patterns å‡½æ•°å¼è¯­è¨€çš„è®¾è®¡æ¨¡å¼ ###
è¿™é‡Œæœ‰å‡ å¥å…³äºå‡ ç§ç¼–ç¨‹èŒƒå¼çš„è¯ï¼Œè§‰å¾—æŒºæœ‰æ„æ€çš„ï¼š

_Do I need to preserve state? (e.g: some entity in a game) -> OOP._

_Am I transforming some input into some kind of output? -> functional. (most of the code)._

_Something algorithmicky? -> procedural._

å†é…ä¸Špptä¸Šé¢çš„å›¾ï¼Œå¥½æç¬‘ï¼Œå“ˆå“ˆ 
![image](/public/img/2015-06-29-å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼çš„ç†è§£_20150701_000748_2716HYp.png)


#### å‡½æ•°å¼è¯­è¨€çš„è®¾è®¡æ¨¡å¼çš„ä¸»è¦å‡ ä¸ªåŸåˆ™ ####

+ **Functions   å‡½æ•°** 

+ **Types       ç±»å‹**

+ **Composition ç»„åˆ** 

### æ ¸å¿ƒçš„FPè®¾è®¡ ###
è¿™é‡Œå…¶å®è¯´çš„æ˜¯å¯¹å‡½æ•°å¼è¯­è¨€çš„ä¸€äº›ç›´è§‚çš„ç†è§£ï¼Œå¯ä»¥ä»è¿™å‡ ä¸ªè§’åº¦å»ç†è§£ï¼Œä»€ä¹ˆæ˜¯å‡½æ•°å¼èŒƒå¼
ä¸é¢å‘å¯¹è±¡ç›¸æ¯”ï¼Œä¸ºäº†åŒæ ·çš„å·¥ç¨‹ç›®æ ‡ï¼Œç”¨äº†å®Œå…¨ä¸åŒçš„æ¦‚å¿µã€‚

#### Steal from mathematics ####

å‡½æ•°å¼è¯­è¨€é‡Œé¢çš„ç¡®å¾ˆå¤šæ•°å­¦çš„æ¦‚å¿µï¼Œæ˜ å°„ï¼Œå°¾é€’å½’ï¼Œå˜æ¢ï¼Œä¸å¯å˜å˜é‡ï¼Œé«˜é˜¶å‡½æ•°ç­‰ç”¨æ•°å­¦çš„è§’åº¦å»å¤„ç†æ•°æ®
ä»¥å‰åœ¨å­¦ä¹ é«˜ç­‰ä»£æ•°çš„æ—¶å€™ï¼Œä¸€ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µå°±æ˜¯æ˜ å°„ï¼ŒçŸ©é˜µå°±æ˜¯ä¸€ä¸ªæ˜ å°„ğ’œã€‚è€Œæ˜ å°„å¯ä»¥ä½œç”¨äºä¸åŒçš„é›†åˆã€‚

>
+ Input and output values already exit
+ A function is not a calculation , just a mapping
+ Input and output values are unchanged(immutableä¸å¯å˜çš„å˜é‡)

ä»ä¸Šé¢è¿™å‡ ç‚¹å¯ä»¥çœ‹å‡ºï¼Œå‡½æ•°å¼è¯­è¨€é‡Œé¢çš„å‡½æ•°çš„æ¦‚å¿µå…¶å®å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªæ˜ å°„ğ’œ/f(x)çš„æ„æ€è€Œä¸æ˜¯è¿ç®—çš„é›†åˆã€‚

![image](/public/img/2015-06-29-å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼çš„ç†è§£_20150701_174224_2716IZw.png)

æ¯”è¾ƒæœ‰è¶£çš„æ˜¯è¿™ä¸€ä¸ªï¼ŒFunctions can work on functions å…ƒç´ æ˜¯å‡½æ•°çš„é›†åˆä¹‹é—´ä¹Ÿæ˜¯å¯ä»¥æ˜ å°„çš„ï¼Œ
ä¹Ÿå°±æ˜¯è¾“å…¥å‡½æ•°ï¼Œç„¶åè¾“å‡ºæ˜¯å‡½æ•°,è¿™é‡Œå¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆå‡½æ•°å¼è¯­è¨€å‡½æ•°æ˜¯å¯ä»¥ä½œä¸ºå‚æ•°ï¼Œè¿”å›å€¼äº†ã€‚

> 
+ Purity
ä»€ä¹ˆæ˜¯çº¯å‡½æ•°ï¼Ÿ

```
Pure functions are easy to reason about 

customer.SetName(newName); //setNameä¹‹åcustomerçŠ¶æ€æ˜¯ä¸æ˜¯è¢«æ”¹å˜äº†ï¼Ÿ
var name = customer.GetName();

let newCustomer = setCustomerName(aCustomer,newName)
let name,newCustomer = getCustomerName(aCustomer) 
//åœ¨å‡½æ•°å¼è¯­è¨€é‡Œé¢ï¼Œæ²¡æœ‰çŠ¶æ€æ‰€ä»¥æ›´åŠ pure?

Pure functions are easy to refactor

let x = doSomething()
let y = doSomethingElse(X)
return y + 1
```
>
+ å¦å¤–ä¸€äº›å¦‚æœå‡½æ•°æ˜¯pureçš„å¥½å¤„ 
+ Laziness å»¶è¿Ÿæ±‚å€¼
_only evaluate when I need the output_
+ Cacheable results 
_same answer every time â€“ "memoization"_
ç¼“å­˜å‡½æ•°ç»“æœ
+ No order dependencies 
_I can evaluate them in any order I like_
æ‰§è¡Œçš„æ—¶å€™ï¼Œä¸éœ€è¦æ ¹æ®å‡½æ•°å®šä¹‰çš„é¡ºåºï¼Œä¸ç”¨è·Ÿcè¯­è¨€é‚£æ ·
+ Parallelizable 
_"embarrassingly parallel"_
å¯ä»¥æ‹¥æŠ±å¹¶å‘

**ä¸Šé¢è¯´çš„å„ç§ä¹Ÿå°±æ˜¯å‡½æ•°æ²¡æœ‰çŠ¶æ€æ²¡æœ‰å‰¯ä½œç”¨ï¼Œè€Œä¸”å˜é‡ä¸å¯å˜ ==> å°±ä»£è¡¨äº† purity** 
è¿™é‡Œæˆ‘æƒ³èµ·erlangé‡Œé¢ï¼Œå…¶å®å¾ˆå¤šæ—¶å€™å‡½æ•°éƒ½ä¸æ˜¯çº¯å‡½æ•°ï¼Œå…¶å®ä¹Ÿæ˜¯æœ‰side effectsçš„

[ä»€ä¹ˆæ˜¯å‡½æ•°å‰¯ä½œç”¨side effects](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8 ) 


### Types are not classes ###
å‡½æ•°å¼è¯­è¨€é‡Œé¢çš„ç±»å‹è·Ÿç±»è¿˜æ˜¯æœ‰å¾ˆå¤§åŒºåˆ«ï¼Œè™½ç„¶ç±»æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€å †æ•°æ®ï¼ˆå‡½æ•°ä¹Ÿå¯ä»¥çœ‹æˆæ˜¯æ•°æ®ï¼‰

>
ä»€ä¹ˆæ˜¯ç±»å‹ï¼Ÿ ç±»å‹åº”è¯¥æ˜¯æ•°æ®çš„å®šä¹‰
ç±»å‹åŒºåˆ†äº†æ•°æ®Dataä»¥åŠæ•°æ®æ“ä½œçš„è¡Œä¸º Behaviour

### Functions are things ###

>
let z = 1;
let add x y = x + y;
å˜é‡çš„å®šä¹‰è·Ÿå‡½æ•°çš„å®šä¹‰éƒ½æ˜¯ç”¨`let`å…³é”®å­—

æ•°å­¦é‡Œé¢å…¶å®å¯ä»¥è®¤ä¸ºä¸€åˆ‡éƒ½æ˜¯å‡½æ•°ï¼Œf(x) = C,å…¶å®æˆ‘ä»¬é€šå¸¸è¯´çš„å¸¸é‡ï¼Œåœ¨æ•°å­¦æ¦‚å¿µçš„ç†è§£ï¼Œåº”è¯¥å«
å¸¸å‡½æ•°ã€‚

å‡½æ•°å¯ä»¥åšå‚æ•°ï¼Œå¯ä»¥åšè¿”å›å€¼ï¼Œå¯ä»¥åœ¨å‡½æ•°å†…å®šä¹‰ï¼Œå°±æ˜¯è¯´ä¸€èˆ¬
å˜é‡èƒ½å‡ºç°çš„åœ°æ–¹ï¼Œå‡½æ•°ä¹Ÿèƒ½å‡ºç°ã€‚

### Composition everywhere ###

å‡½æ•°å¼è¯­è¨€æ²¡æœ‰ç»§æ‰¿,æ¥å£çš„æ¦‚å¿µï¼ŒåŸºæœ¬éƒ½æ˜¯åˆ©ç”¨ç»„åˆå»å®ç°ç»§æ‰¿çš„åŠŸèƒ½ã€‚

+ å‡½æ•°ç»„åˆ
+ ç±»å‹çš„ç»„åˆ


#### é¢†åŸŸæ¨¡å‹çš„è®¾è®¡-ç±»å‹çš„è®¾è®¡ ####


```
Types represent constraints on input and output 
ç±»å‹ä»£è¡¨è¾“å…¥è¾“å‡ºçš„çº¦æŸï¼Œä¹Ÿæ˜¯ç¨‹åºçš„æ–‡æ¡£

type Suit = Club | Diamond | Spade | Heart
type String50 = // non-null, not more than 50 chars 
type EmailAddress = // non-null, must contain â€˜@â€™ 
type StringTransformer = string -> string
type GetCustomer = CustomerId -> Customer option

type PaymentMethod =
| Cash
| Cheque of ChequeNumber
| Card of CardType * CardNumber
OO version:
interface IPaymentMethod {..} 
class Cash : IPaymentMethod {..} 
class Cheque : IPaymentMethod {..} 
class Card : IPaymentMethod {..}
class Evil : IPaymentMethod {..}
```

![image](/public/img/2015-06-29-å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼çš„ç†è§£_20150702_114712_2716HtF.png)


![image](/public/img/2015-06-29-å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼çš„ç†è§£_20150702_115017_2716U3L.png)

>å‡½æ•°å°±æ˜¯ä¸€ä¸ªè¾“å…¥é›†åˆï¼Œè¾“å‡ºé›†åˆä¹‹é—´çš„å˜æ¢
>ä»å›¾å·¦ä¸Šè§’çœ‹åˆ°ï¼Œå¤–éƒ¨æ•°æ®ä¸ç³»ç»Ÿå†…éƒ¨çš„æ•°æ®ç±»å‹æ˜¯æ€ä¹ˆè½¬æ¢çš„
å¯ä»¥æ›´åŠ æ¸…æ™°çš„ç†è§£ç³»ç»Ÿçš„é€»è¾‘ï¼Œç³»ç»Ÿé€»è¾‘æ˜¯ç”±æ•°æ®é©±åŠ¨çš„ï¼Œç³»ç»Ÿçš„é€»è¾‘å°±æ˜¯æ•°æ®æµçš„è¡¨ç°
 

#### Function are parameters å‡½æ•°ä½œä¸ºå‚æ•° ####
å‚æ•°åŒ–æ‰€æœ‰çš„ä¸œè¥¿


```c
public static int Product(int n) {
    int product = 1;//åˆå§‹åŒ–
    for (int i = 1; i <= n; i++)//éå†
    {
    product *= i; 
    }
    return product;
}
public static int Sum(int n)
{
    int sum = 0;//åˆå§‹åŒ–
    for (int i = 1; i <= n; i++)//éå†
    {
    sum += i; 
    }
    return sum; 
}

Sum ä¸ Product é‡Œé¢ for è¿™ä¸ªéå†æ“ä½œæ˜¯ä¸€æ ·çš„ï¼Œå¯ä»¥æŠ½è±¡å‡ºæ¥

å¦‚æœç”¨F#æ˜¯è¿™ä¹ˆå†™
let product n =
let initialValue = 1
let action productSoFar x = productSoFar * x
[1..n] |> List.fold action initialValue

let sum n =
let initialValue = 0
let action sumSoFar x = sumSoFar+x
[1..n] |> List.fold action initialValue

let printList anAction aList = for i in aList do
anAction i
// val printList :
//   ('a -> unit) -> seq<'a> -> unit
```

#### æ¥å£ï¼Ÿå‡½æ•°ç±»å‹å°±æ˜¯æ¥å£ ####
+ ç­–ç•¥æ¨¡å¼

```
Object-oriented strategy pattern:
class MyClass
{
   public MyClass(IBunchOfStuff strategy) {..}
   int DoSomethingWithStuff(int x)
   {
return _strategy.DoSomething(x) }
}

F#:
let DoSomethingWithStuff strategy x = strategy x

```
+ è£…é¥°æ¨¡å¼
```
Functional equivalent of decorator pattern
let add1 x = x + 1 // int -> int
let logged f x =
   printfn "input is %A" x
   let result = f x
   printfn "output is %A" result
   result
let add1Decorated = // int -> int 
logged add1

[1..5] |> List.map add1
[1..5] |> List.map add1Decorated
```

+ ä¾èµ–æ³¨å…¥ï¼ŸIOCï¼Ÿ



 




#### Chainning Functions ####
+ Error handling ,Async
+ Monads

#### Dealing with warpped data####
+ Lifting ,Functor
+ Validation with Applicatives

#### Agrregating data and operations ####

+ Monoids



































